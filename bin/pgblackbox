#!/usr/bin/perl -w
#
# pgblackbox:
# Record certain information about a PostgreSQL database server for later
# analysis and debugging.
#
# Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: pgblackbox,v 1.5 2006-09-11 10:07:00 chris Exp $';

use strict;

package main;

# Horrible boilerplate to set up appropriate library paths.
use FindBin;
use lib "$FindBin::Bin/../perllib";
use lib "$FindBin::Bin/../../perllib";

use Carp;
use Data::Dumper;
use DBI;
use DBD::Pg;
use POSIX;

use PGBlackbox;

my $dbuser = 'postgres';
my $dbpass = '';
my $dbname_dummy = 'dummy';

my $compression_prog = "/usr/bin/bzip2";
my $compression_suffix = ".bz2";

#my $spool_dir = "/var/spool/pgblackbox";
my $spool_dir = "/tmp/pgblackbox";
my $spool_slots = 360;  # half an hour

my $dbh;        # master db connection
my %dbh_by_db;  # handles for individual databases

# dbh [DBNAME]
# Return a handle open on the given DBNAME, or the dummy database if it is not
# specified. Handles open on individual non-dummy databases are not cached.
sub dbh (;$);
sub dbh (;$) {
    if (@_) {
        my $dbname = shift;
        croak "DBNAME must not be undef" unless (defined($dbname));

        my $dbh = $dbh_by_db{$dbname};
        if ($dbh && !$dbh->ping()) {
            # XXX log that handle has gone away.
            undef $dbh;
        }
        if (!defined($dbh)) {
            $dbh = DBI->connect("dbi:Pg:dbname=$dbname", $dbuser, $dbpass, {
                                AutoCommit => 1, PrintError => 0, Warn => 0
                            });
            # log if undef
        }

        $dbh_by_db{$dbname} = $dbh if ($dbh && $dbname eq $dbname_dummy);

        return $dbh;
    } else {
        return dbh($dbname_dummy);
    }
}

# dbname ID
# Return the name of the database with the given ID.
sub dbname ($) {
    my $id = shift;
    our %dbname;
    if (!exists($dbname{$id})) {
        $dbname{$id}
            = dbh()->selectrow_array('
                    select datname
                    from pg_stat_database
                    where datid = ?', {}, $id);
        $dbname{$id} ||= "<db#$id>";
    }
    return $dbname{$id};
}

# tablename DATABASE TABLE
# Return the name of the TABLE (ID) in the given DATABASE (ID).
sub tablename ($$) {
    my ($d, $t) = @_;
    # Connect and then disconnect asap. So to avoid unnecessary overhead we
    # grab all the table names we can every time we are called, so this
    # function should connect to the database once on startup and once for each
    # table added to any database.
    my $dbname = dbname($d);
    our %tablename;
    if (!exists($tablename{$dbname}) || !exists($tablename{$dbname}->{$t})) {
        $tablename{$dbname} ||= { };
        my $dbh = dbh($dbname);
        my $x = $dbh->selectall_arrayref('
                    select relid, relname
                    from pg_stat_user_tables');
        foreach (@$x) {
            my ($id, $name) = @$_;
            $tablename{$dbname}->{$id} = $name;
        }
        $tablename{$dbname}->{$t} ||= "<rel#$t>";
        $dbh->disconnect();
    }
    return $tablename{$dbname}->{$t};
}

# get_state
# Record relevant state of the database.
sub get_state () {
    my $pg_stat_activity
        = dbh()->selectall_arrayref('
                select datid, datname, procpid, usesysid, usename,
                    current_query
                from pg_stat_activity');
    my $pg_locks
        = dbh()->selectall_arrayref('
                select relation, database, transaction, pid, mode, granted
                from pg_locks');

    # Now grab information about the individual clients, if available.
    #
    # XXX Also use this opportunity to clean up old client rows.
    my $clients = [ ];
    foreach (@{$pg_stat_activity}) {
        my ($datid, $datname, $procpid) = @$_;
        my $row = dbh($datname)->selectrow_arrayref('
                        select backendpid, host,
                            clientaddr, clientport, serveraddr, serverport,
                            dbname, dbuser,
                            pid, ppid,
                            uid, gid,
                            argv, environ, cwd,
                            connected
                        from debug.client
                        where backendpid = ?', {}, $procpid);
        next unless ($row);
        $row->[12] ||= '';
        $row->[12] = [split(/\0/, $row->[12])];
        $row->[13] ||= '';
        $row->[13] = [split(/\0/, $row->[13])];
        push(@$clients, $row) if ($row);
    }

    # maybe record other circumstantial information, e.g. load?

    return ($pg_stat_activity, $pg_locks, $clients);
}

# spoolfile
# Return current spoolfile object.
sub spoolfile () {
    our $current_spoolfile;

    if (!defined($current_spoolfile) || $current_spoolfile->eof()) {
        my @l = localtime(time());
        foreach my $d (map { POSIX::strftime($_, @l) } qw(%Y %Y/%m %Y/%m/%d)) {
            if (!-d "$spool_dir/$d" && !mkdir("$spool_dir/$d", 0755) && !$!{EEXIST}) {
                die "$spool_dir/$d: mkdir: $!";
            }
        }
        
        my $filename = POSIX::strftime('%Y/%m/%d/%Y%m%dT%H%M%S.pgb', @l);
        my $s = PGBlackbox::Spoolfile->create("$spool_dir/$filename", $spool_slots);
        if (!ref($s)) {
            die "$spool_dir/$filename: $s";
        }

        $current_spoolfile = $s;

        # XXX really we should see whether the last-written spool file has any
        # free space and open that, but can't be bothered at the moment.
    }

    return $current_spoolfile;
}


while (1) {
    my ($pg_stat_activity, $pg_locks, $clients) = get_state();

    my $err = spoolfile()->append($pg_stat_activity, $pg_locks, $clients);
    warn $err if ($err);
warn "now cursor = " . spoolfile()->cursor() . "\n";
    
    sleep(5);
}
